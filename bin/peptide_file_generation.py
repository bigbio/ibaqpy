#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re

import click
import pandas as pd
from typing_extensions import OrderedDict

from ibaq.ibaqpy_commons import *


def get_mbr_hit(scan: str):
    """
  This function annotates if the peptide is inferred or not by Match between Runs algorithm (1), 0 if the peptide is
  identified in the corresponding file.
  :param scan: scan value
  :return:
  """
    return 1 if pd.isna(scan) else 0


def parse_uniprot_accession(uniprot_id: str) -> str:
    """
    Parse the uniprot accession from the uniprot id in the form of
    tr|CONTAMINANT_Q3SX28|CONTAMINANT_TPM2_BOVIN and convert to CONTAMINANT_TPM2_BOVIN
    :param uniprot_id: uniprot id
    :return: uniprot accession
    """
    uniprot_list = uniprot_id.split(";")
    result_uniprot_list = []
    for accession in uniprot_list:
        if accession.count("|") == 2:
            accession = accession.split("|")[2]
        result_uniprot_list.append(accession)
    return ";".join(result_uniprot_list)


def remove_extension_file(filename: str) -> str:
    """
  The filename can have
  :param filename:
  :return:
  """
    return filename.replace('.raw', '').replace('.RAW', '').replace('.mzML', '').replace('.wiff', '')


def get_study_accession(sample_id: str) -> str:
    """
  Get the project accession from the Sample accession. The function expected a sample accession in the following
  format PROJECT-SAMPLEID
  :param sample_id: Sample Accession
  :return: study accession
  """
    return sample_id.split('-')[0]


def get_reference_name(reference_spectrum: str) -> str:
    """
    Get the reference name from Reference column. The function expected a reference name in the following format eg.
    20150820_Haura-Pilot-TMT1-bRPLC03-2.mzML_controllerType=0 controllerNumber=1 scan=16340
    :param reference_spectrum:
    :return: reference name
    """
    return re.split(r'\.mzML|\.MZML|\.raw|\.RAW', reference_spectrum)[0]


def get_run_mztab(ms_run: str, metadata: OrderedDict) -> str:
    """
  Convert the ms_run into a reference file for merging with msstats output
  :param ms_run: ms_run index in mztab
  :param metadata:  metadata information in mztab
  :return: file name
  """
    m = re.search(r"\[([A-Za-z0-9_]+)\]", ms_run)
    file_location = metadata['ms_run[' + str(m.group(1)) + "]-location"]
    file_location = remove_extension_file(file_location)
    return os.path.basename(file_location)


def get_scan_mztab(ms_run: str) -> str:
    """
  Get the scan number for an mzML spectrum in mzTab. The format of the reference
  must be controllerType=0 controllerNumber=1 scan=30121
  :param ms_run: the original ms_run reference in mzTab
  :return: the scan index
  """
    reference_parts = ms_run.split()
    return reference_parts[-1]


def best_probability_error_bestsearch_engine(probability: float) -> float:
    """
  Convert probability to a Best search engine score
  :param probability: probability
  :return:
  """
    return 1 - probability


def print_help_msg(command) -> None:
    """
  Print help information
  :param command: command to print helps
  :return: print help
  """
    with click.Context(command) as ctx:
        click.echo(command.get_help(ctx))


@click.command()
@click.option("-m", "--msstats", help="MsStats file import generated by quantms", required=True)
@click.option("-s", "--sdrf", help="SDRF file import generated by quantms", required=True)
@click.option("--compress", help="Read all files compress", is_flag=True)
@click.option("--min_aa", help="Minimum number of amino acids to filter peptides", default=7)
@click.option("--min_unique", help="Minimum number of unique peptides to filter proteins", default=2)
@click.option("-o", "--output", help="Peptide intensity file including other all properties for normalization")
def peptide_file_generation(msstats: str, sdrf: str, compress: bool, min_aa: int, min_unique: int, output: str) -> None:
    """
    Conversion of peptide intensity information into a file that containers peptide intensities but also
    the metadata around the conditions, the retention time, charge states, etc.

    :param msstats: MsStats file import generated by quantms
    :param sdrf: SDRF file import generated by quantms
    :param min_aa: Minimum number of amino acids to filter peptides
    :param min_unique: Minimum number of unique peptides to filter proteins
    :param compress: Read all files compress
    :param output: Peptide intensity file including other all properties for normalization
  """

    if msstats is None or sdrf is None or output is None:
        print_help_msg(peptide_file_generation)
        exit(1)

    compression_method = 'gzip' if compress else None

    # Read the msstats file
    msstats_df = pd.read_csv(msstats, sep=',', compression=compression_method)
    # Remove 0 intensity signals from the msstats file
    msstats_df = msstats_df[msstats_df[INTENSITY] > 0]
    msstats_df[PEPTIDE_CANONICAL] = msstats_df.apply(lambda x: get_canonical_peptide(x[PEPTIDE_SEQUENCE]), axis=1)
    # Only peptides with more than min_aa (default: 7) amino acids are retained
    msstats_df = msstats_df[msstats_df.apply(lambda x: len(x[PEPTIDE_CANONICAL]) >= min_aa, axis=1)]
    # Only proteins with unique peptides number greater than min_unique (default: 2) are retained
    unique_peptides = set(msstats_df.groupby(PEPTIDE_CANONICAL).filter(lambda x: len(set(x[PROTEIN_NAME])) == 1)[
                              PEPTIDE_CANONICAL].tolist())
    strong_proteins = set(msstats_df[msstats_df[PEPTIDE_CANONICAL].isin(unique_peptides)].groupby(PROTEIN_NAME).filter(
        lambda x: len(set(x[PEPTIDE_CANONICAL])) >= min_unique)[PROTEIN_NAME].tolist())
    msstats_df = msstats_df[msstats_df[PROTEIN_NAME].isin(strong_proteins)]

    msstats_df.rename(
        columns={'ProteinName': PROTEIN_NAME, 'PeptideSequence': PEPTIDE_SEQUENCE, 'PrecursorCharge': PEPTIDE_CHARGE,
                 'Run': RUN,
                 'Condition': CONDITION, 'Intensity': INTENSITY}, inplace=True)

    print(msstats_df)

    msstats_df[PROTEIN_NAME] = msstats_df[PROTEIN_NAME].apply(parse_uniprot_accession)

    # Read the sdrf file
    sdrf_df = pd.read_csv(sdrf, sep='\t', compression=compression_method)
    sdrf_df[REFERENCE] = sdrf_df['comment[data file]'].apply(remove_extension_file)
    print(sdrf_df)

    if FRACTION not in msstats_df.columns:
        msstats_df[FRACTION] = 1
        msstats_df = msstats_df[
            [PROTEIN_NAME, PEPTIDE_SEQUENCE, PEPTIDE_CHARGE, INTENSITY, REFERENCE, CONDITION, RUN,
             BIOREPLICATE, FRACTION, FRAGMENT_ION, ISOTOPE_LABEL_TYPE]]

    # Merged the SDRF with Resulted file
    labels = set(sdrf_df['comment[label]'])
    if CHANNEL not in msstats_df.columns:
        msstats_df[REFERENCE] = msstats_df[REFERENCE].apply(remove_extension_file)
        result_df = pd.merge(msstats_df, sdrf_df[['source name', REFERENCE]], how='left', on=[REFERENCE])
    elif 'TMT' in ','.join(labels) or 'tmt' in ','.join(labels):
        if (len(labels) > 11 or "TMT134N" in labels or "TMT133C" in labels
                or "TMT133N" in labels or "TMT132C" in labels or "TMT132N" in labels):
            choice = TMT16plex
        elif len(labels) == 11 or "TMT131C" in labels:
            choice = TMT11plex
        elif len(labels) > 6:
            choice = TMT10plex
        else:
            choice = TMT6plex
        choice = pd.DataFrame.from_dict(choice, orient='index', columns=[CHANNEL]).reset_index().rename(
            columns={'index': 'comment[label]'})
        sdrf_df = sdrf_df.merge(choice, on='comment[label]', how='left')
        msstats_df[REFERENCE] = msstats_df[REFERENCE].apply(get_reference_name)
        result_df = pd.merge(msstats_df, sdrf_df[['source name', REFERENCE, CHANNEL]], how='left',
                             on=[REFERENCE, CHANNEL])
        # result_df.drop(CHANNEL, axis=1, inplace=True)
        result_df = result_df[result_df["Condition"] != "Empty"]
        result_df.rename(columns={'Charge': PEPTIDE_CHARGE}, inplace=True)
    elif 'ITRAQ' in ','.join(labels) or 'itraq' in ','.join(labels):
        if len(labels) > 4:
            choice = ITRAQ8plex
        else:
            choice = ITRAQ4plex
        choice = pd.DataFrame.from_dict(choice, orient='index', columns=[CHANNEL]).reset_index().rename(
            columns={'index': 'comment[label]'})
        sdrf_df = sdrf_df.merge(choice, on='comment[label]', how='left')
        msstats_df[REFERENCE] = msstats_df[REFERENCE].apply(get_reference_name)
        result_df = pd.merge(msstats_df, sdrf_df[['source name', REFERENCE, CHANNEL]], how='left',
                             on=[REFERENCE, CHANNEL])
        result_df = result_df[result_df["Condition"] != "Empty"]
        result_df.rename(columns={'Charge': PEPTIDE_CHARGE}, inplace=True)
    else:
        print("Warning: Only support label free, TMT and ITRAQ experiment!")
        exit(1)

    result_df.rename(columns={'source name': SAMPLE_ID}, inplace=True)

    result_df[STUDY_ID] = result_df[SAMPLE_ID].apply(get_study_accession)

    result_df.to_csv(output, index=False, sep=',')
    print(result_df)


if __name__ == '__main__':
    peptide_file_generation()
